// Generated by Dart Safe Data Class Generator. * Change this header on extension settings *
// ignore_for_file: type=lint
import 'package:flutter/foundation.dart';
import 'package:flutter/widgets.dart';

enum Status { active, inactive }

@immutable
class Types {
  final int? age;
  final num radius;
  final double height;
  final bool? isPremium;
  final Status status; // enum
  final Status? lastStatus; // enum
  final String name;
  final List<String> names;
  final Map<String, int>? info;
  final List<Map<String, dynamic>> objects;
  final Color color;
  final List<Color>? colors;
  final DateTime? date;
  final List<DateTime> dates;
  final IconData icon;
  final List<IconData>? icons;
  final AnotherClass? another;
  const Types({
    this.age,
    this.radius = 0,
    this.height = 0.0,
    this.isPremium,
    required this.status,
    this.lastStatus,
    this.name = '',
    this.names = const [],
    this.info,
    this.objects = const [],
    required this.color,
    this.colors,
    this.date,
    this.dates = const [],
    required this.icon,
    this.icons,
    this.another,
  });



  // final List<AnotherClass>? anothers;

  @override
  String toString() {
    return 'Types(age: $age, radius: $radius, height: $height, isPremium: $isPremium, status: $status, lastStatus: $lastStatus, name: $name, names: $names, info: $info, objects: $objects, color: $color, colors: $colors, date: $date, dates: $dates, icon: $icon, icons: $icons, another: $another)';
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
  
    return other is Types &&
        other.age == age &&
        other.radius == radius &&
        other.height == height &&
        other.isPremium == isPremium &&
        other.status == status &&
        other.lastStatus == lastStatus &&
        other.name == name &&
        listEquals(other.names, names) &&
        mapEquals(other.info, info) &&
        listEquals(other.objects, objects) &&
        other.color == color &&
        listEquals(other.colors, colors) &&
        other.date == date &&
        listEquals(other.dates, dates) &&
        other.icon == icon &&
        listEquals(other.icons, icons) &&
        other.another == another;
  }

  @override
  int get hashCode {
    return age.hashCode ^
        radius.hashCode ^
        height.hashCode ^
        isPremium.hashCode ^
        status.hashCode ^
        lastStatus.hashCode ^
        name.hashCode ^
        names.hashCode ^
        info.hashCode ^
        objects.hashCode ^
        color.hashCode ^
        colors.hashCode ^
        date.hashCode ^
        dates.hashCode ^
        icon.hashCode ^
        icons.hashCode ^
        another.hashCode;
  }

  Types copyWith({
    int? age,
    num? radius,
    double? height,
    bool? isPremium,
    Status? status,
    Status? lastStatus,
    String? name,
    List<String>? names,
    Map<String, int>? info,
    List<Map<String, dynamic>>? objects,
    Color? color,
    List<Color>? colors,
    DateTime? date,
    List<DateTime>? dates,
    IconData? icon,
    List<IconData>? icons,
    AnotherClass? another,
  }) {
    return Types(
      age: age ?? this.age,
      radius: radius ?? this.radius,
      height: height ?? this.height,
      isPremium: isPremium ?? this.isPremium,
      status: status ?? this.status,
      lastStatus: lastStatus ?? this.lastStatus,
      name: name ?? this.name,
      names: names ?? this.names,
      info: info ?? this.info,
      objects: objects ?? this.objects,
      color: color ?? this.color,
      colors: colors ?? this.colors,
      date: date ?? this.date,
      dates: dates ?? this.dates,
      icon: icon ?? this.icon,
      icons: icons ?? this.icons,
      another: another ?? this.another,
    );
  }

  Map<String, dynamic> toMap() {
    return {
      'age': age,
      'radius': radius,
      'height': height,
      'is_premium': isPremium,
      'status': status.name,
      'last_status': lastStatus?.name,
      'name': name,
      'names': names,
      'info': info,
      'objects': objects.map((x) => x).toList(),
      'color': color.value,
      'colors': colors?.map((x) => x.value).toList(),
      'date': date?.toIso8601String(),
      'dates': dates.map((x) => x.toIso8601String()).toList(),
      'icon': icon.codePoint,
      'icons': icons?.map((x) => x.codePoint).toList(),
      'another': another?.toMap(),
    };
  }

  factory Types.fromMap(Map<String, dynamic> map) {
    T cast<T>(String k) => map[k] is T
        ? map[k] as T
        : throw ArgumentError.value(map[k], k, '$T ← ${map[k].runtimeType}');
    return Types(
      age: cast<num?>('age')?.toInt(),
      radius: cast<num?>('radius') ?? 0,
      height: cast<num?>('height')?.toDouble() ?? 0.0,
      isPremium: cast<bool?>('is_premium'),
      status: Status.values
          .byName(cast<String?>('status') ?? Status.values.first.name),
      lastStatus: map['last_status'] != null
          ? Status.values
              .byName(cast<String?>('last_status') ?? Status.values.first.name)
          : null,
      name: cast<String?>('name') ?? '',
      names: List<String>.from(cast<Iterable?>('names') ?? const <String>[]),
      info:
          map['info'] != null ? Map<String, int>.from(cast<Map>('info')) : null,
      objects: List<Map<String, dynamic>>.from(cast<Iterable?>('objects')
              ?.map((x) => Map<String, dynamic>.from(x as Map)) ??
          const <Map<String, dynamic>>[]),
      color: Color(cast<int>('color')),
      colors: map['colors'] != null
          ? List<Color>.from(cast<Iterable>('colors')
              .map((x) => Color((x as num?)?.toInt() ?? 0)))
          : null,
      date: map['date'] != null ? DateTime.parse(cast<String>('date')) : null,
      dates: List<DateTime>.from(cast<Iterable?>('dates')
              ?.map((x) => DateTime.parse(x as String? ?? '')) ??
          const <DateTime>[]),
      icon: IconData(cast<int>('icon')),
      icons: map['icons'] != null
          ? List<IconData>.from(cast<Iterable>('icons')
              .map((x) => IconData((x as num?)?.toInt() ?? 0)))
          : null,
      another: map['another'] != null
          ? AnotherClass.fromMap(Map.from(cast<Map>('another')))
          : null,
    );
  }
}

@immutable
class AnotherClass {
  final String id;
  const AnotherClass({
    this.id = '',
  });

  AnotherClass copyWith({
    String? id,
  }) {
    return AnotherClass(
      id: id ?? this.id,
    );
  }

  Map<String, dynamic> toMap() {
    return {
      'id': id,
    };
  }

  factory AnotherClass.fromMap(Map<String, dynamic> map) {
    T cast<T>(String k) => map[k] is T
        ? map[k] as T
        : throw ArgumentError.value(map[k], k, '$T ← ${map[k].runtimeType}');
    return AnotherClass(
      id: cast<String?>('id') ?? '',
    );
  }

  @override
  String toString() => 'AnotherClass(id: $id)';

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;

    return other is AnotherClass && other.id == id;
  }

  @override
  int get hashCode => id.hashCode;
}
