// Generated by Dart Safe Data Class Generator. * Change this header on extension settings *
// ignore_for_file: avoid_dynamic_calls, lines_longer_than_80_chars
import 'dart:convert';

import 'package:collection/collection.dart';
import 'package:flutter/foundation.dart';
import 'package:flutter/widgets.dart';

@immutable
class Types {
  final Color? color;
  final DateTime? date;
  final IconData? icon;
  final List<String>? names;
  final num id;
  final double radius;
  final int? age;

  const Types({
    // this.id = 0.0,
    // this.id,
    required this.color,
    required this.date,
    required this.icon,
    this.names = const [],
    this.id = 0,
    this.radius = 0.0,
    this.age,
  });

  factory Types.fromMap(Map<String, dynamic> map) {
    T isA<T>(String k) => map[k] is T
        ? map[k] as T
        : throw ArgumentError.value(map[k], k, '$T ← ${map[k].runtimeType}');
    return Types(
      color: map['color'] != null ? Color(isA<int>('color')) : null,
      date: map['date'] != null ? DateTime.parse(isA<String>('date')) : null,
      icon: map['icon'] != null ? IconData(isA<int>('icon')) : null,
      names: map['names'] != null
          ? List<String>.from(isA<Iterable>('names'))
          : null,
      id: isA<num>('id'),
      radius: isA<num>('radius').toDouble(),
      age: isA<num?>('age')?.toInt(),
    );
  }

  @override
  String toString() {
    return 'Types(color: $color, date: $date, icon: $icon, names: $names, id: $id, radius: $radius, age: $age)';
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
  
    return other is Types &&
        other.color == color &&
        other.date == date &&
        other.icon == icon &&
        listEquals(other.names, names) &&
        other.id == id &&
        other.radius == radius &&
        other.age == age;
  }

  @override
  int get hashCode {
    return color.hashCode ^
        date.hashCode ^
        icon.hashCode ^
        names.hashCode ^
        id.hashCode ^
        radius.hashCode ^
        age.hashCode;
  }

  Types copyWith({
    Color? color,
    DateTime? date,
    IconData? icon,
    List<String>? names,
    num? id,
    double? radius,
    int? age,
  }) {
    return Types(
      color: color ?? this.color,
      date: date ?? this.date,
      icon: icon ?? this.icon,
      names: names ?? this.names,
      id: id ?? this.id,
      radius: radius ?? this.radius,
      age: age ?? this.age,
    );
  }

  Map<String, dynamic> toMap() {
    return {
      'color': color?.value,
      'date': date?.toIso8601String(),
      'icon': icon?.codePoint,
      'names': names,
      'id': id,
      'radius': radius,
      'age': age,
    };
  }
}

@immutable
class Test {
  final List<String>? members; //  // toCustom is optional.
  final Map<String, dynamic> address;
  // final Payment paymentType; // enum // comment
  final List<Color>? date;
  // final Timestamp? time; // ignore
  final String? name;
  final bool? isPremium;
  final IconData icon;
  final Color? color;
  final int id;
  final double? radius;
  const Test({
    this.members,
    this.address = const {},
    this.date,
    this.name,
    this.isPremium,
    required this.icon,
    this.color,
    this.id = 0,
    this.radius,
  });

  @override
  int get hashCode {
    return members.hashCode ^
        address.hashCode ^
        date.hashCode ^
        name.hashCode ^
        isPremium.hashCode ^
        icon.hashCode ^
        color.hashCode ^
        id.hashCode ^
        radius.hashCode;
  }

  Test copyWith({
    List<String>? members,
    Map<String, dynamic>? address,
    List<Color>? date,
    String? name,
    bool? isPremium,
    IconData? icon,
    Color? color,
    int? id,
    double? radius,
  }) {
    return Test(
      members: members ?? this.members,
      address: address ?? this.address,
      date: date ?? this.date,
      name: name ?? this.name,
      isPremium: isPremium ?? this.isPremium,
      icon: icon ?? this.icon,
      color: color ?? this.color,
      id: id ?? this.id,
      radius: radius ?? this.radius,
    );
  }

  factory Test.fromJson(String source) =>
      Test.fromMap(json.decode(source) as Map<String, dynamic>);

  @override
  String toString() {
    return 'Test(members: $members, address: $address, date: $date, name: $name, isPremium: $isPremium, icon: $icon, color: $color, id: $id, radius: $radius)';
  }

  factory Test.fromMap(Map<String, dynamic> map) {
    T isA<T>(String k) => map[k] is T
        ? map[k] as T
        : throw ArgumentError.value(map[k], k, '$T ← ${map[k].runtimeType}');
    return Test(
      members: map['members'] != null
          ? List<String>.from(isA<Iterable<String>>('members'))
          : null,
      address: Map<String, dynamic>.from(isA<Map<String, dynamic>>('address')),
      date: map['date'] != null
          ? List<Color>.from(isA<Iterable>('date').map((x) => Color(x)))
          : null,
      name: isA<String?>('name'),
      isPremium: isA<bool?>('is_premium'),
      icon: IconData(isA<int>('icon'), fontFamily: 'MaterialIcons'),
      color: map['color'] != null ? Color(isA<int>('color')) : null,
      id: isA<int>('id'),
      radius: isA<double?>('radius'),
    );
  }

  Map<String, dynamic> toMap() {
    return {
      'members': members,
      'address': address,
      'date': date?.map((x) => x.value).toList(),
      'name': name,
      'is_premium': isPremium,
      'icon': icon.codePoint,
      'color': color?.value,
      'id': id,
      'radius': radius,
    };
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    final collectionEquals = const DeepCollectionEquality().equals;

    return other is Test &&
        collectionEquals(other.members, members) &&
        collectionEquals(other.address, address) &&
        collectionEquals(other.date, date) &&
        other.name == name &&
        other.isPremium == isPremium &&
        other.icon == icon &&
        other.color == color &&
        other.id == id &&
        other.radius == radius;
  }
}
