// Generated by Dart Safe Data Class Generator. * Change this header on extension settings *
// ignore_for_file: type=lint
import 'package:flutter/foundation.dart';
import 'package:flutter/widgets.dart';

enum Status { active, inactive }

@immutable
class Types {
  final int? age;
  final num radius;
  final double height;
  final bool? isPremium;
  final Status status; // enum
  final Status? lastStatus; // enum
  final String name;
  final List<String> names;
  final Map<String, int>? info;
  final List<Map<String, dynamic>> objects;
  final Color color;
  final List<Color>? colors;
  final DateTime? date;
  final List<DateTime> dates;
  final IconData icon;
  final List<IconData>? icons;
  final AnotherClass? another;
  final List<AnotherClass> anothers;
  final List<AnotherClass>? noOthers;
  const Types({
    this.age,
    this.radius = 0,
    this.height = 0.0,
    this.isPremium,
    required this.status,
    this.lastStatus,
    this.name = '',
    this.names = const [],
    this.info,
    this.objects = const [],
    required this.color,
    this.colors,
    this.date,
    this.dates = const [],
    required this.icon,
    this.icons,
    this.another,
    this.anothers = const [],
    this.noOthers = const [],
  });

  @override
  String toString() {
    return 'Types(age: $age, radius: $radius, height: $height, isPremium: $isPremium, status: $status, lastStatus: $lastStatus, name: $name, names: $names, info: $info, objects: $objects, color: $color, colors: $colors, date: $date, dates: $dates, icon: $icon, icons: $icons, another: $another, anothers: $anothers, noOthers: $noOthers)';
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
  
    return other is Types &&
        other.age == age &&
        other.radius == radius &&
        other.height == height &&
        other.isPremium == isPremium &&
        other.status == status &&
        other.lastStatus == lastStatus &&
        other.name == name &&
        listEquals(other.names, names) &&
        mapEquals(other.info, info) &&
        listEquals(other.objects, objects) &&
        other.color == color &&
        listEquals(other.colors, colors) &&
        other.date == date &&
        listEquals(other.dates, dates) &&
        other.icon == icon &&
        listEquals(other.icons, icons) &&
        other.another == another &&
        listEquals(other.anothers, anothers) &&
        listEquals(other.noOthers, noOthers);
  }

  @override
  int get hashCode {
    return age.hashCode ^
        radius.hashCode ^
        height.hashCode ^
        isPremium.hashCode ^
        status.hashCode ^
        lastStatus.hashCode ^
        name.hashCode ^
        names.hashCode ^
        info.hashCode ^
        objects.hashCode ^
        color.hashCode ^
        colors.hashCode ^
        date.hashCode ^
        dates.hashCode ^
        icon.hashCode ^
        icons.hashCode ^
        another.hashCode ^
        anothers.hashCode ^
        noOthers.hashCode;
  }

  Types copyWith({
    int? age,
    num? radius,
    double? height,
    bool? isPremium,
    Status? status,
    Status? lastStatus,
    String? name,
    List<String>? names,
    Map<String, int>? info,
    List<Map<String, dynamic>>? objects,
    Color? color,
    List<Color>? colors,
    DateTime? date,
    List<DateTime>? dates,
    IconData? icon,
    List<IconData>? icons,
    AnotherClass? another,
    List<AnotherClass>? anothers,
    List<AnotherClass>? noOthers,
  }) {
    return Types(
      age: age ?? this.age,
      radius: radius ?? this.radius,
      height: height ?? this.height,
      isPremium: isPremium ?? this.isPremium,
      status: status ?? this.status,
      lastStatus: lastStatus ?? this.lastStatus,
      name: name ?? this.name,
      names: names ?? this.names,
      info: info ?? this.info,
      objects: objects ?? this.objects,
      color: color ?? this.color,
      colors: colors ?? this.colors,
      date: date ?? this.date,
      dates: dates ?? this.dates,
      icon: icon ?? this.icon,
      icons: icons ?? this.icons,
      another: another ?? this.another,
      anothers: anothers ?? this.anothers,
      noOthers: noOthers ?? this.noOthers,
    );
  }

  Map<String, dynamic> toMap() {
    return {
      'age': age,
      'radius': radius,
      'height': height,
      'is_premium': isPremium,
      'status': status.index,
      'last_status': lastStatus?.index,
      'name': name,
      'names': names,
      'info': info,
      'objects': objects.map((x) => x).toList(),
      'color': color.value,
      'colors': colors?.map((x) => x.value).toList(),
      'date': date?.toIso8601String(),
      'dates': dates.map((x) => x.toIso8601String()).toList(),
      'icon': icon.codePoint,
      'icons': icons?.map((x) => x.codePoint).toList(),
      'another': another?.toMap(),
      'anothers': anothers.map((x) => x.toMap()).toList(),
      'no_others': noOthers?.map((x) => x.toMap()).toList(),
    };
  }

  factory Types.fromMap(Map<String, dynamic> map) {
    T cast<T>(String k) => map[k] is T
        ? map[k] as T
        : throw ArgumentError.value(map[k], k, '$T ← ${map[k].runtimeType}');
    return Types(
      age: cast<num?>('age')?.toInt(),
      radius: cast<num>('radius'),
      height: cast<num>('height').toDouble(),
      isPremium: cast<bool?>('is_premium'),
      status: Status.values[cast<num>('status').toInt()],
      lastStatus: map['last_status'] != null
          ? Status.values[cast<num>('last_status').toInt()]
          : null,
      name: cast<String>('name'),
      names: List<String>.from(cast<Iterable>('names')),
      info:
          map['info'] != null ? Map<String, int>.from(cast<Map>('info')) : null,
      objects: List<Map<String, dynamic>>.from(cast<Iterable>('objects')
          .map((x) => Map<String, dynamic>.from(x as Map))),
      color: Color(cast<int>('color')),
      colors: map['colors'] != null
          ? List<Color>.from(
              cast<Iterable>('colors').map((x) => Color((x as num).toInt())))
          : null,
      date: map['date'] != null ? DateTime.parse(cast<String>('date')) : null,
      dates: List<DateTime>.from(
          cast<Iterable>('dates').map((x) => DateTime.parse(x as String))),
      icon: IconData(cast<int>('icon')),
      icons: map['icons'] != null
          ? List<IconData>.from(
              cast<Iterable>('icons').map((x) => IconData((x as num).toInt())))
          : null,
      another: map['another'] != null
          ? AnotherClass.fromMap(Map.from(cast<Map>('another')))
          : null,
      anothers: List<AnotherClass>.from(cast<Iterable>('anothers')
          .map((x) => AnotherClass.fromMap(Map.from(x as Map)))),
      noOthers: map['no_others'] != null
          ? List<AnotherClass>.from(cast<Iterable>('noOthers')
              .map((x) => AnotherClass.fromMap(Map.from(x as Map))))
          : null,
    );
  }
}

@immutable
class AnotherClass {
  final String id;
  const AnotherClass({
    this.id = '',
  });

  AnotherClass copyWith({
    String? id,
  }) {
    return AnotherClass(
      id: id ?? this.id,
    );
  }

  Map<String, dynamic> toMap() {
    return {
      'id': id,
    };
  }

  factory AnotherClass.fromMap(Map<String, dynamic> map) {
    T cast<T>(String k) => map[k] is T
        ? map[k] as T
        : throw ArgumentError.value(map[k], k, '$T ← ${map[k].runtimeType}');
    return AnotherClass(
      id: cast<String?>('id') ?? '',
    );
  }

  @override
  String toString() => 'AnotherClass(id: $id)';

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;

    return other is AnotherClass && other.id == id;
  }

  @override
  int get hashCode => id.hashCode;
}
